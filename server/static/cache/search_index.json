{
  "清华大学第一弹：DeepSeek从入门到精通.pdf": {
    "words": [
      "pdf",
      "清华大学第一弹",
      "deepseek从入门到精通"
    ],
    "headers": [],
    "last_modified": 1740971272.031306,
    "type": "pdf",
    "size": 5618017
  },
  "第一周学习计划.md": {
    "words": [
      "三级缓存原理分析",
      "注解处理器",
      "water",
      "需求分析和设计",
      "上传github",
      "leetcode提交次数",
      "11",
      "of",
      "记录并发控制要点",
      "substring",
      "repeating",
      "第一周学习计划",
      "更新进度看板",
      "8",
      "工具准备",
      "注意事项",
      "https",
      "reference",
      "3",
      "10次",
      "spring官方文档",
      "错题本整理",
      "nth",
      "下周计划制定",
      "21",
      "30前完成学习",
      "二叉树专题",
      "14",
      "vm",
      "笔记工具",
      "node",
      "下午",
      "第一周",
      "基本概念学习",
      "每日详细安排",
      "most",
      "动态规划入门",
      "递归和迭代方案对比",
      "arrays",
      "周日",
      "阶段一",
      "依赖注入实现",
      "整理线程池最佳实践",
      "项目实战",
      "oracle",
      "七大核心参数详解",
      "每天必须在23",
      "github仓库分类",
      "周一",
      "四种拒绝策略分析",
      "idea",
      "guides",
      "dev",
      "letter",
      "博客",
      "使用jvisualvm监控内存分配",
      "保持适度运动",
      "并发安全保证",
      "周四",
      "gctuning",
      "代码行数",
      "18",
      "本周追踪指标",
      "numbers",
      "资源链接",
      "phone",
      "更新学习日志",
      "com",
      "记录要点",
      "without",
      "完成简化版spring",
      "30",
      "3sum",
      "准备周末项目",
      "周六",
      "栈",
      "深入理解concurrenthashmap源码",
      "周三",
      "建立学习追踪系统",
      "framework",
      "周度总结",
      "手写简单版本的线程安全map",
      "源码分析",
      "整理本周知识点",
      "19",
      "en",
      "2",
      "22",
      "更新github进度",
      "draw",
      "b",
      "list",
      "9",
      "重点难点必须记录",
      "add",
      "项目设计和规划",
      "jdk",
      "container",
      "上午",
      "索引优化实践",
      "题目",
      "12",
      "end",
      "掌握jvm内存模型和gc算法",
      "16",
      "github提交次数",
      "算法刷题",
      "sum",
      "7次",
      "technotes",
      "top",
      "ioc容器项目",
      "性能测试",
      "算法训练",
      "本周目标",
      "周二",
      "树结构分析",
      "indexes",
      "0",
      "4",
      "准备面试要点",
      "内存分配流程图",
      "堆",
      "双向链表设计",
      "20",
      "线程池专题",
      "lru缓存实现",
      "problemset",
      "jvm专题",
      "绘图工具",
      "15",
      "optimization",
      "characters",
      "a",
      "单元测试编写",
      "100",
      "45",
      "from",
      "beandefinition设计",
      "javase",
      "5",
      "更新学习进度追踪",
      "spring",
      "编码实现",
      "put方法实现",
      "jvisualvm",
      "注意休息",
      "实操任务",
      "1",
      "docs",
      "mysql",
      "spring循环依赖",
      "io",
      "代码必须提交到github",
      "完成题解笔记",
      "笔记数",
      "算法题解复盘",
      "median",
      "常见面试题准备",
      "核心功能实现",
      "palindromic",
      "00",
      "知识点回顾",
      "整理spring核心原理",
      "完成10道",
      "500行",
      "markdown编辑器",
      "concurrenthashmap深入",
      "本地开发环境",
      "liked",
      "longest",
      "树的遍历方法实现",
      "学习笔记",
      "leetcode",
      "jvm内存结构",
      "remove",
      "refman",
      "sorted",
      "周五",
      "整理并发编程笔记",
      "17",
      "jvm调优指南",
      "number",
      "绘制线程池工作流程图",
      "html",
      "哈希表结合",
      "mysql索引",
      "方法区等",
      "combinations",
      "每日复盘",
      "整理今日知识点",
      "two",
      "手绘循环依赖解决方案",
      "parentheses",
      "valid",
      "questions",
      "算法专题训练",
      "简单dp题目练习",
      "旗舰版",
      "5篇",
      "with",
      "doc"
    ],
    "headers": [
      "第一周学习计划（阶段一·第一周）",
      "🎯 本周目标",
      "📅 每日详细安排",
      "周一",
      "19:30-20:15 算法训练",
      "20:15-21:45 JVM专题",
      "21:45-22:00 每日复盘",
      "周二",
      "19:30-20:15 算法训练",
      "20:15-21:45 ConcurrentHashMap深入",
      "21:45-22:00 每日复盘",
      "周三",
      "19:30-20:15 算法训练",
      "20:15-21:45 线程池专题",
      "21:45-22:00 每日复盘",
      "周四",
      "19:30-20:15 算法训练",
      "20:15-21:45 Spring循环依赖",
      "21:45-22:00 每日复盘",
      "周五",
      "19:30-20:15 算法训练",
      "20:15-21:45 MySQL索引",
      "21:45-22:00 每日复盘",
      "周六",
      "上午 (9:00-12:00) Spring IOC容器项目",
      "下午 (14:00-18:00) 算法专题训练",
      "周日",
      "上午 (9:00-12:00) LRU缓存实现",
      "下午 (14:00-18:00) 周度总结",
      "📊 本周追踪指标",
      "🔧 工具准备",
      "⚠️ 注意事项",
      "📝 资源链接"
    ],
    "last_modified": 1740897174.4215837,
    "type": "md",
    "size": 3861
  },
  "服务端开发与面试知识手册(1).pdf": {
    "words": [
      "服务端开发与面试知识手册",
      "pdf",
      "1"
    ],
    "headers": [],
    "last_modified": 1742282767.0703988,
    "type": "pdf",
    "size": 26497139
  },
  "深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） (华章原创精品) - 周志明.pdf": {
    "words": [
      "pdf",
      "第3版",
      "华章原创精品",
      "深入理解java虚拟机",
      "周志明",
      "jvm高级特性与最佳实践"
    ],
    "headers": [],
    "last_modified": 1736440609.6959352,
    "type": "pdf",
    "size": 31490889
  },
  "找对英语学习方法的第一本书.pdf": {
    "words": [
      "pdf",
      "找对英语学习方法的第一本书"
    ],
    "headers": [],
    "last_modified": 1742309172.7524903,
    "type": "pdf",
    "size": 73789332
  },
  "清华大学第三弹：普通人如何抓住DeepSeek红利.pdf": {
    "words": [
      "普通人如何抓住deepseek红利",
      "pdf",
      "清华大学第三弹"
    ],
    "headers": [],
    "last_modified": 1740971294.0933306,
    "type": "pdf",
    "size": 5178656
  },
  "清华大学第二弹：DeepSeek如何赋能职场应用.pdf": {
    "words": [
      "pdf",
      "deepseek如何赋能职场应用",
      "清华大学第二弹"
    ],
    "headers": [],
    "last_modified": 1740971290.0897331,
    "type": "pdf",
    "size": 16104776
  },
  "153页.6.5万字-DeepSeek行业应用案例集：解锁智能变革密码（完整版）-浙江大学-2025年2月.pdf": {
    "words": [
      "pdf",
      "153页",
      "浙江大学",
      "完整版",
      "deepseek行业应用案例集",
      "5万字",
      "6",
      "2025年2月",
      "解锁智能变革密码"
    ],
    "headers": [],
    "last_modified": 1740623367.346826,
    "type": "pdf",
    "size": 5111762
  },
  "大模型基础 完整版.pdf": {
    "words": [
      "大模型基础",
      "pdf",
      "完整版"
    ],
    "headers": [],
    "last_modified": 1741572250.7291622,
    "type": "pdf",
    "size": 22232181
  },
  "测试子目录/编程珠玑  第2版(修订版).pdf": {
    "words": [
      "修订版",
      "pdf",
      "第2版",
      "编程珠玑"
    ],
    "headers": [],
    "last_modified": 1736408660.2265818,
    "type": "pdf",
    "size": 47199032
  },
  "测试子目录/子目录/AQS_万字图文全面解析.md": {
    "words": [
      "独占方式释放锁",
      "接着",
      "线程一被唤醒成功",
      "的后置节点",
      "first",
      "picture",
      "的区别",
      "nextc",
      "相比使用",
      "的流程都已经分析完了",
      "volatile",
      "方法来唤醒线程",
      "具体操作流程如下",
      "执行的逻辑一步步拆解来看",
      "多线程争用资源被阻塞时会进入此队列",
      "protected",
      "只能和",
      "locks",
      "的地方",
      "中还有一个",
      "interruptmode",
      "上面所有的加锁场景都是基于",
      "对应的前置节点是否为",
      "获取锁后使用",
      "exception",
      "the",
      "同时来加锁",
      "main",
      "如果抢占成功",
      "这里会先判断",
      "都指向第一个",
      "节点的",
      "unpark",
      "parkandcheckinterrupt",
      "具体代码可以参考上面内容",
      "它用来替代传统的",
      "相关的",
      "以",
      "那么就不应该",
      "节点信息",
      "也就是我们现在的",
      "三个线程",
      "compareandsettail",
      "线程一加锁成功",
      "获取锁的标志",
      "实现原理",
      "cancelacquire",
      "插队获取到了锁",
      "逻辑后",
      "则代表队列中存在等待节点",
      "println",
      "维护了一个",
      "的默认实现",
      "接着会释放该节点的锁",
      "和上面",
      "释放锁来展示了",
      "也来执行加锁操作",
      "clean",
      "然后执行",
      "的值",
      "目录如下",
      "节点的后置节点",
      "中实现了",
      "具体看下抢占锁代码实现",
      "nonfairtryacquire",
      "就会得到",
      "代表有等待线程",
      "nonfairsync",
      "此时看下",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndqwm2y0ntriyw",
      "等待队列中已经没有了数据",
      "指令修改",
      "方法会返回",
      "看完了",
      "中数据如图",
      "具体执行流程如下",
      "c",
      "如果不为",
      "返回",
      "和一个",
      "最后",
      "if",
      "线程进来直接利用",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndjjnwq2otmzoa",
      "此时线程二获取锁成功",
      "currentthread",
      "继续执行",
      "已经将",
      "nextwaiter",
      "into",
      "4",
      "节点重新指向",
      "p",
      "通过上面的分析我们知道",
      "getstate",
      "是一个双向链表",
      "中的方法",
      "尝试获取资源",
      "see",
      "为",
      "执行完后我们可以看下",
      "成功则返回",
      "a",
      "示例",
      "会具体讲解的",
      "这里先从",
      "throw_ie",
      "而这时",
      "执行完成",
      "并发抢占锁",
      "5",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndjjnwqyzwiyyw",
      "被空置的节点数据等着被",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndmzmmrmnmzknq",
      "reinterrupt",
      "代码实现如下",
      "设置为",
      "当前线程如要入队排列",
      "会产生先唤醒再挂起的死锁",
      "compareandsetwaitstatus",
      "接着判断占有锁的线程是否为当前线程",
      "s",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndm1zdi0othhyg",
      "unlinkcancelledwaiters",
      "抢占锁失败的分析",
      "1",
      "enq",
      "addconditionwaiter",
      "方便后续被垃圾回收掉",
      "如果是则累加",
      "maximum",
      "isonsyncqueue",
      "interrupted",
      "的机制",
      "能够保证多线程下的可见性",
      "获取锁实现原理",
      "思维导图",
      "fifo",
      "hasqueuedpredecessors",
      "变为",
      "接着调用",
      "等待其他获取锁的线程释放锁才能够被唤醒",
      "而是退出",
      "方法中首先会获取",
      "pred",
      "是否为",
      "先进先出",
      "如果是则尝试加锁",
      "abstractqueuedsynchronizer",
      "线程三加锁",
      "这里我们还是用之前的线程模型来举例子",
      "transferforsignal",
      "会唤醒被挂起的",
      "会再次尝试加锁",
      "因此不会产生加锁方式而产生的死锁出现",
      "从而继续争抢锁",
      "基本上都是使用",
      "加锁成功时",
      "public",
      "demo",
      "所以执行",
      "抢占锁失败就很简单了",
      "可能存在某个线程",
      "这就是可重入锁的具体实现",
      "入队操作中",
      "公平锁在加锁的时候",
      "线程二唤醒继续加锁",
      "加入等待队列的代码在上面也已经分析过",
      "state",
      "此时等待队列的",
      "author",
      "这里会执行",
      "前言",
      "但是",
      "exclusiveownerthread",
      "所以我们也对",
      "reentrantlock",
      "这个组件",
      "h",
      "逻辑",
      "must",
      "然后空置之前的",
      "extends",
      "如果",
      "线程一",
      "firstwaiter",
      "this",
      "一枝花算不算浪漫",
      "成立",
      "start",
      "跳出",
      "有了深刻的理解",
      "newcondition",
      "节点是否为当前线程",
      "值为",
      "实现的",
      "fairsync",
      "exclusive",
      "直到另外线程释放锁才被唤醒",
      "thread",
      "我们不得不说",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndq0odq0zdi3zq",
      "中才出现的",
      "conditionobject",
      "方法是判断当前的线程节点是不是在同步队列中",
      "执行完第二个红框处",
      "arg",
      "直接返回",
      "释放锁的时候也要依次递减",
      "与",
      "方法使用",
      "且使用",
      "需要使用",
      "unparksuccessor",
      "因为上一步已经释放了锁",
      "如果不是则直接抛出异常",
      "会继续尝试获取锁",
      "java",
      "具体流程图如下",
      "也会被挂起",
      "release",
      "执行完后等待队列数据如下",
      "所提供的核心功能",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndmymtk0mtdmnq",
      "initializing",
      "这里还有一些方法并没有列出来",
      "中等待队列的数据模型",
      "第一遍循环时",
      "释放锁的时候",
      "当然它还有很多其他的特性",
      "后会返回",
      "new",
      "cpu",
      "string",
      "线程三抢占锁失败",
      "这里主要是将",
      "compareandsethead",
      "out",
      "static",
      "在最坏的情况下",
      "执行完成之后",
      "中队列数据如图",
      "抢占锁成功",
      "此时线程可以直接尝试获取锁",
      "先判断",
      "如果返回",
      "semaphore",
      "illegalmonitorstateexception",
      "使用",
      "的",
      "这里就会执行",
      "内部实现",
      "如果存在其他等待线程",
      "先看下具体的代码实现",
      "被设置成",
      "后及时的",
      "代表队列中没有节点或者仅有一个节点是当前线程创建的节点",
      "此时不是原子性操作",
      "queue",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndnlnjc4ntfimw",
      "如果存在节点则会直接入队等待",
      "底层就是基于",
      "元素",
      "线程二",
      "会先判断",
      "性能高于",
      "1590419228808",
      "等待队列中是存在节点",
      "image",
      "等待队列中是否有元素存在",
      "above",
      "接下来我们以",
      "抢占锁成功后",
      "我们将",
      "尝试抢占锁",
      "会接着尝试获取锁",
      "接着执行",
      "failed",
      "insert",
      "会返回当前线程创建的节点信息",
      "等待队列中的数据都等待着被垃圾回收",
      "count",
      "这里先用一张图来解释",
      "三",
      "垃圾回收",
      "变为了",
      "中的数据",
      "则继续判断",
      "而接着",
      "代表获取锁失败",
      "interruptedexception",
      "null",
      "final",
      "next",
      "这个方法会先判断当前传入的",
      "0",
      "实现原理图解",
      "挂起当前线程",
      "如果获取锁成功",
      "却眼巴巴的看到",
      "指针",
      "break",
      "线程等待队列",
      "最后执行",
      "使用的时候要注意",
      "接着还是一步步拆解来看",
      "中等待队列数据为",
      "获取锁成功",
      "接着开始通过",
      "会等于",
      "up",
      "的值不会成功",
      "大家要记清楚",
      "上面已经介绍了",
      "do",
      "param",
      "节点数据",
      "的地方继续执行",
      "则会继续被挂起",
      "则代表此时没有线程持有锁",
      "方法将当前线程加入等待队列尾部",
      "数据",
      "此时已经有了",
      "object",
      "这里用了一步一图的方式结合三个线程依次加锁",
      "同样会执行",
      "代表共享资源",
      "的操作都是通过",
      "catch",
      "且",
      "来保证其并发修改的安全性",
      "执行完成后可以查看",
      "等着其他线程释放锁来唤醒它",
      "但是并未将",
      "那么自己也会加入到等待队列尾部",
      "lock",
      "等待队列中的节点",
      "其他线程来加锁时则会失败",
      "reportinterruptafterwait",
      "aqs",
      "是",
      "的等待队列中",
      "唤醒被挂起的",
      "如果修改成功则代表获取锁成功",
      "线程一释放锁成功",
      "这里会通过画图来分析每个线程加锁",
      "尝试更新",
      "mode",
      "此时重新将",
      "可能存在这种情况",
      "先通过",
      "predecessor",
      "finally",
      "已经被唤醒",
      "队列中的数据",
      "队列中没有等待获取锁的节点",
      "循环",
      "线程一释放锁",
      "当",
      "getexclusiveownerthread",
      "synchronized",
      "我们按照真实场景来分析",
      "判断",
      "继续尝试获取锁",
      "lastwaiter",
      "同时底层实现的是",
      "waitstatue",
      "help",
      "线程二唤醒线程一",
      "为例",
      "进入",
      "这就是体现",
      "sethead",
      "releases",
      "gc",
      "但是会存在导致",
      "try",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndjjnzdimjc2nq",
      "tryrelease",
      "while",
      "如果是则继续使用",
      "compareandsetstate",
      "被挂起",
      "失败则返回",
      "abstractqueuesynchronizer",
      "有序加锁",
      "抢占锁失败",
      "args",
      "接着判断",
      "作为实例",
      "等",
      "我们先看下",
      "fullyrelease",
      "如果同时有",
      "使用示例代码",
      "private",
      "的等待队列里面了",
      "操作挂起",
      "shouldparkafterfailedacquire",
      "线程三",
      "并且唤醒当前线程",
      "被唤醒的",
      "辛辛苦苦排队等到自己获取锁",
      "线程二加锁成功",
      "此时",
      "加锁失败的线程会被放入一个",
      "checkinterruptwhilewaiting",
      "节点后面",
      "在",
      "节点",
      "中队列数据如下",
      "也就是我们上面图中",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndm0mzkzyzu4zg",
      "也不必取唤醒所有线程",
      "加锁失败",
      "执行完",
      "比列会被",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndjjnzc5otlknq",
      "此时等待队列中数据如下图",
      "前面我们已经看到过",
      "对象的独占锁被设置为",
      "被加入等待队列",
      "当前线程需要入队等待",
      "我们还是用上面的",
      "具体实现原理",
      "await",
      "就静静的待在",
      "首先我们考虑下",
      "队列中只有线程一创建的一个",
      "printstacktrace",
      "tryacquire",
      "如果更新成功则代表当前线程加锁成功",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndqyntbmmza4oq",
      "作为突破点通过源码和画图的形式一步步了解",
      "png",
      "selfinterrupt",
      "reentrantreadwritelock",
      "执行结果如下图",
      "这可能就是",
      "countdownlatch",
      "唤醒线程的开销",
      "谈到并发",
      "exceeded",
      "因为",
      "head",
      "expect",
      "park",
      "这里之前也有讲过",
      "对应的",
      "是在",
      "因此也不会产生先唤醒再挂起的死锁",
      "尝试释放资源",
      "notify",
      "设置锁的标志",
      "for",
      "e",
      "那么接着判断",
      "方法来尝试获取锁",
      "属性",
      "locksupport",
      "指向一个新创建的",
      "1590419214352",
      "boolean",
      "队列中数据如图所示",
      "修改",
      "并返回当前线程的前置节点",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndm3zwi5mzq5ma",
      "isheldexclusively",
      "只不过公平锁单独实现了",
      "了",
      "执行的流程如下",
      "此时队列中就有了两个",
      "目录结构",
      "加锁失败时",
      "指针指向",
      "公平锁在获取锁是也是首先会执行",
      "是否等于",
      "signal",
      "此时等待对内中的",
      "cas",
      "28",
      "先获取锁",
      "则说明当前对象的锁已经被其他线程所占有",
      "sync",
      "如下所示",
      "此时等待队列的数据如图",
      "setexclusiveownerthread",
      "20",
      "这里要操作的就是将",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndnmote5nmrlyw",
      "释放锁后会唤醒",
      "这段代码很有意思",
      "ycappd",
      "necessary",
      "中数据",
      "将当前线程加入到",
      "队列中",
      "acquire",
      "已经获取到锁",
      "不为空",
      "执行",
      "节点挂到",
      "throws",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndnhmweynmu5na",
      "接着之前被",
      "节点指向",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndnlmdm2nzlhza",
      "释放锁后",
      "则",
      "执行成功",
      "这里",
      "会继续重试获取锁",
      "有图可以看出",
      "stateoffset",
      "公平锁",
      "操作来尝试修改",
      "可以精准的对多个不同条件进行控制",
      "这种情况代表有节点正在做入队操作",
      "中",
      "代表",
      "操作来修改",
      "方法",
      "接着将",
      "in",
      "这段代码首先会创建一个和当前线程绑定的",
      "concurrent",
      "savedstate",
      "中的具体实现",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndnhyjvmzdrjnw",
      "如果已经唤醒",
      "指令将",
      "另外",
      "unsafe",
      "内部实现原理",
      "一句话就是不会产生死锁",
      "性能虽然优于",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndqynwzhmmu5zq",
      "也就是说此时可能有线程已经获取锁同时可能已经调用了",
      "wait",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lze2lze3mjfjzdi1mtuznmu3y2m",
      "system",
      "有类似于",
      "接着执行第二遍循环",
      "首先是",
      "singal",
      "修改为",
      "等待队列中",
      "方法将当前线程加入到等待队列中",
      "ws",
      "进行控制",
      "这里我们来继续说下",
      "且获取锁的线程不是当前线程",
      "如果此时又来了一个",
      "方法来唤醒",
      "通过",
      "的时候",
      "直接调用",
      "中提供了很多关于锁的实现方法",
      "且设置对象独占锁线程为当前线程",
      "return",
      "变量必然会失败",
      "方法执行完后",
      "释放锁时",
      "initialize",
      "线程四",
      "被唤醒后",
      "总结",
      "如果队列中只有一个",
      "acquires",
      "如果获取锁失败",
      "执行流程",
      "绘图",
      "具体代码如下",
      "而还未执行",
      "的情况",
      "compareandswapint",
      "所以",
      "其实就是使用",
      "这个并未在图中画出来",
      "如果加锁失败或者",
      "整体的吞吐效率会高点",
      "另外还介绍了",
      "因此通常来说比较推荐使用",
      "则代表当前对象锁已经被占有",
      "即是抽象的队列式的同步器",
      "tail",
      "释放锁的代码",
      "则执行",
      "reentrantlockdemo",
      "具体流程如下图",
      "此时看",
      "简介",
      "后",
      "这种属于一种极端情况",
      "7",
      "如果不是则返回",
      "线程饥饿",
      "的比较",
      "会减少唤起线程的数量",
      "用",
      "这种情况就会出现竞争",
      "累加",
      "class",
      "free",
      "尝试重新获取锁",
      "node",
      "指向",
      "默认创建非公平锁的原因之一了",
      "其中",
      "加锁成功过则将当前节点设置为",
      "images",
      "unlock",
      "方法中的",
      "万字图文全面解析",
      "尽量让大家更容易去理解",
      "流程到此终结",
      "调用",
      "等都是基于",
      "如果获取锁失败继续会被挂起",
      "我们总结下",
      "线程二释放锁",
      "将自己加入到一个",
      "具体原理我们可以用一张图来简单概括",
      "做到真正的先来后到",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndmxzgzmmgi2zg",
      "实现源码学习",
      "独占方式获取锁",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndmynzyxzdk2mq",
      "这里首先会执行",
      "继续往后执行",
      "饥饿问题可以暂时忽略",
      "这个方法具体实现在",
      "释放锁后此时会唤醒被挂起的",
      "util",
      "操作设置",
      "现在来分析下释放锁的过程",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndnjmjexmjgzoq",
      "释放锁",
      "这个到后面",
      "那么",
      "uml",
      "内部的数据结构和实现原理",
      "方法中首先调用",
      "方法来看",
      "waitstatus",
      "线程二释放锁成功",
      "内部定义了很多锁相关的方法",
      "throw",
      "关键字一起使用",
      "那我们接着来看一下",
      "这里会用当前线程创建一个",
      "性能",
      "实现线程间的协作",
      "线程一执行",
      "的具体执行流程",
      "setstate",
      "就会通过",
      "inserts",
      "这里使用的",
      "to",
      "修改当前节点",
      "error",
      "已经被修改为",
      "流程和上面大致相同",
      "调用之前解析过的",
      "的实现方式和实现原理",
      "操作",
      "int",
      "方法挂起当前线程并",
      "的讲解方式",
      "场景分析",
      "parkandcheckniterrupt",
      "这就是所谓的",
      "线程二抢占锁失败",
      "因为此时线程一的",
      "一直获取不到锁",
      "那么再来分析",
      "唤醒",
      "如果是当前线程则可重入获取锁",
      "可以减少",
      "dosignal",
      "而",
      "在第一个红框处",
      "具体实现代码为",
      "中的",
      "true",
      "内部数据为",
      "修改当前节点的前置节点",
      "将",
      "所谓的",
      "不过相比性能而言",
      "acquirequeued",
      "值回被改为",
      "公平锁实现原理",
      "我们熟知的",
      "释放锁及",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndjjndzingrlmq",
      "值",
      "awaite",
      "false",
      "执行方式是一致的",
      "prev",
      "和",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndmwyjuyntzkzq",
      "void",
      "addwaiter",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndm2m2u4nzkwmg",
      "图",
      "update",
      "例如",
      "先判断当前线程是否为获取锁的线程",
      "t",
      "并且只能唤醒一个或者全部的等待队列",
      "的实现原理",
      "date",
      "然后使用",
      "已经有值",
      "被唤醒",
      "这种方式实现线程间协作更加安全和高效",
      "的具体实现",
      "2020",
      "cancelled",
      "非公平锁",
      "的前置节点不是",
      "此时传入的参数为",
      "方法执行入队操作",
      "通过线程场景来讲解",
      "为双向链表",
      "源码",
      "主要对外提供",
      "入队后会修改",
      "jfif",
      "仍然需要待在等待队列中被挂起",
      "condition",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndnjmzq2mmq2yq",
      "接着就来看看",
      "中公平锁的",
      "文章准备模拟多线程竞争锁",
      "来实现的",
      "else",
      "指针为空",
      "中的数据如下图",
      "释放锁的场景来进行分析",
      "ahr0chm6ly91c2vylwdvbgqty2rulnhpdhuuaw8vmjaymc81lzivmtcxzdjkndjjogu1zti2oa",
      "先看看",
      "的前置节点是否为",
      "current"
    ],
    "headers": [
      "AQS 万字图文全面解析",
      "前言",
      "AQS 实现原理",
      "目录结构",
      "场景分析",
      "线程一加锁成功",
      "线程二抢占锁失败",
      "线程三抢占锁失败",
      "线程一释放锁",
      "线程二唤醒继续加锁",
      "线程二释放锁/线程三加锁",
      "公平锁实现原理",
      "Condition 实现原理",
      "Condition 简介",
      "Condition Demo 示例",
      "Condition 实现原理图解",
      "Condition 总结",
      "总结"
    ],
    "last_modified": 1735785448.0,
    "type": "md",
    "size": 31574
  },
  "测试2/清华大学第五弹：DeepSeek与AI幻觉.pdf": {
    "words": [
      "deepseek与ai幻觉",
      "pdf",
      "清华大学第五弹"
    ],
    "headers": [],
    "last_modified": 1740971305.2073455,
    "type": "pdf",
    "size": 4377661
  },
  "测试2/清华大学第四弹：让科研像聊天一样简单.pdf": {
    "words": [
      "pdf",
      "让科研像聊天一样简单",
      "清华大学第四弹"
    ],
    "headers": [],
    "last_modified": 1740971301.44123,
    "type": "pdf",
    "size": 11939104
  }
}